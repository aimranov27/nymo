package nymo

import (
	"context"
	"crypto/ecdsa"
	"crypto/tls"
	"math/big"
	"sync"
	"time"

	"github.com/nymo-net/nymo/pb"
)

type User struct {
	cfg    Config
	db     Database
	cohort uint32
	key    *ecdsa.PrivateKey
	cert   tls.Certificate

	peerLock sync.RWMutex
	peers    map[[hashTruncate]byte]*peer
	total    uint
	numIn    uint
	retry    peerRetrier
}

// Address returns the address of the user.
func (u *User) Address() *Address {
	return &Address{
		cohort: u.cohort,
		x:      u.key.X,
		y:      u.key.Y,
	}
}

// Run runs the main loop for user as a Nymo peer client.
func (u *User) Run(ctx context.Context) {
	if u.cfg.LocalPeerAnnounce {
		go func() {
			if e := u.ipv4PeerAnnounce(ctx); e != nil {
				u.cfg.Logger.Print(e)
			}
		}()
		go func() {
			if e := u.ipv6PeerAnnounce(ctx); e != nil {
				u.cfg.Logger.Print(e)
			}
		}()
	}
	if u.cfg.LocalPeerDiscover {
		go func() {
			if e := u.ipv4PeerDiscover(ctx); e != nil {
				u.cfg.Logger.Print(e)
			}
		}()
		go func() {
			if e := u.ipv6PeerDiscover(ctx); e != nil {
				u.cfg.Logger.Print(e)
			}
		}()
	}

	for ctx.Err() == nil {
		u.dialNewPeers(ctx)
		t := time.NewTimer(u.cfg.ScanPeerTime)
		select {
		case <-t.C:
		case <-ctx.Done():
			t.Stop()
			return
		}
	}
}

// AddPeer adds a peer URL, which computes the hash of the URL and synchronously calls Database.AddPeer.
func (u *User) AddPeer(url string) {
	hash := hasher([]byte(url))
	u.db.AddPeer(url, &pb.Digest{
		Hash:   hash[:hashTruncate],
		Cohort: cohortNumber, // XXX: when unknown, as wildcard
	})
}

// OpenSupernode opens a supernode (a relay node). For arguments usage see OpenUser.
func OpenSupernode(db Database, cert tls.Certificate, cfg *Config) *User {
	if cfg == nil {
		cfg = DefaultConfig()
	}

	hash := hasher(cert.Certificate[0])
	return &User{
		cfg:    *cfg,
		db:     db,
		cohort: cohortNumber,
		cert:   cert,
		peers:  map[[hashTruncate]byte]*peer{truncateHash(hash[:]): nil},
		retry:  peerRetrier{m: make(map[string]time.Time)},
	}
}

// OpenUser opens a user generated by GenerateUser, where the userKey argument should be
// exactly what GenerateUser returned.
//
// cert should contain a valid certificate that is used as the mTLS cert (on both client and server side).
//
// if cfg is nil, DefaultConfig will be used.
func OpenUser(db Database, userKey []byte, cert tls.Certificate, cfg *Config) *User {
	if cfg == nil {
		cfg = DefaultConfig()
	}

	key := new(ecdsa.PrivateKey)
	key.Curve = curve
	key.D = new(big.Int).SetBytes(userKey)
	key.X, key.Y = curve.ScalarBaseMult(userKey)

	hash := hasher(cert.Certificate[0])
	return &User{
		cfg:    *cfg,
		db:     db,
		cohort: getCohort(key.X, key.Y),
		key:    key,
		cert:   cert,
		peers:  map[[hashTruncate]byte]*peer{truncateHash(hash[:]): nil},
		retry:  peerRetrier{m: make(map[string]time.Time)},
	}
}

// GenerateUser generates a new Nymo user. The returned key is opaque to the frontend
// and should be stored secretly.
func GenerateUser() ([]byte, error) {
	key, err := ecdsa.GenerateKey(curve, cReader)
	if err != nil {
		return nil, err
	}
	return key.D.Bytes(), nil
}
